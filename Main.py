#arch# -*- coding: utf-8 -*-
"""
Created on Wed Nov 28 11:29:50 2018

@author: Marc Lagueux-Bresse

This is the laucher of the scheduler. It handles processes kept in
Processes.json

The results are logged in Result.json
Complete log in case of errors is found here: error.out

"""
import time
import concurrent.futures as cf
from WorkflowManager import (Process,RelativeDay,Output,processFile)
import json
import os
import pandas as pd
import traceback




if __name__=='__main__':
    #Logs result after a thread had finished
    def logresult(proc):
        """Records the error in the log file as well as the result file. If process in vba no log available"""
        
        # If the returning value from the task is an error
        if isinstance(proc.result(),Exception):
            
            err = proc.result()
            #If error comes with a customized message, records message, traceback and time in Result.json
            if hasattr(err, 'message'):
                
                procs[proc].GenerateResult(str(err.message),str(traceback.extract_tb(err.__traceback__)[1]),str(pd.Timestamp.now()))
       
            #If error comes without a customized message, records default message, traceback and time in Result.json
            else:
                
                procs[proc].GenerateResult(str(err),str(traceback.extract_tb(err.__traceback__)[1]),str(pd.Timestamp.now()))
        
        #Record the time and success of the run
        else:
            
            
            procs[proc].GenerateResult('Successfully completed','Successfully completed',str(pd.Timestamp.now()))
      
            
        print(f'Removing {procs[proc].processname}')
        procs.pop(proc)
        
    while True:
        #Try statement in case network is unavailable
        try:
           
            executor = cf.ThreadPoolExecutor()
            procs={}
            
            while True:                
                pr=[]
                
        #Loads the process list with all variables (path, name, inputs...) and creates process objects (stored in pr)
            
                with open(processFile) as f:
                    
                    processLst_ = json.load(f)
                    
                    for Desk in processLst_['Desk']:
        
                        for pro in Desk['Process']: 
         
                            pr.append(Process(path=pro['Path'],name=pro['Name'],Desk=Desk['Name'],inputs=pro['Inputs'],hour = pro['Hour'],Language = pro['Language'],Frequency = pro['Frequency'],RelativeDayStr=pro['RelativeDayStr'],Pr_Date=pd.Timestamp(pd.Timestamp.now().strftime("%Y%m%d")),Continuous =pro['Continuous']))
                          
                #Check if process must be triggered by user input  
                       
                filepath='Z:\\Fund_Oversight\\OVERSIGHT\\Operations\\Tools\\Scheduler\\'
                
                
                if os.path.isfile(filepath + 'ForceRun.json'):
                    #Get the ticket generated by GUI
                    with open(filepath + 'ForceRun.json') as f:
                        jload = json.load(f)
                        
                    #Delete the ticket
                    os.remove(filepath + 'ForceRun.json')
                    #Creates a set of key dates relative to the process date
                    relDay=RelativeDay(pd.to_datetime(jload[0]['Date']))
                    
                    #Reverse key date of process to position relative to date in the ticket
                    relDay.reversedates(pro.RelativeDayStr)
                    
                    #Build instance of process class with name and date from ticket and other 
                    #attributes inherited from process configuration file.
                    
                    pro =[x for x in pr if x.name==jload[0]['Process']]
                    
                    if pro: 
                        #Create process instance
                        ForceRun = Process(path=pro[0].path,name=pro[0].name,inputs=pro[0].inputs,Desk=pro[0].Desk,Language = pro[0].Language,Frequency = None,RelativeDayStr=pro[0].RelativeDayStr,hour=pro[0].hour,Pr_Date=relDay.SD)
                        #Create output instance with process attributes
                        Output_=Output(Pr_Date=ForceRun.Pr_Date,processname=ForceRun.name,Desk=ForceRun.Desk,RelativeDayStr=ForceRun.RelativeDayStr)
                        #Launch thread to complete the process
                        procs[executor.submit(ForceRun.run)]=Output_
                        
                    #Adds manual process to queue                    
                    print(f'Adding manual process {ForceRun.name}')
                

                #Looping through each process from the process configuration file
                for pro in pr:
                    
                    
                    Output_=Output(Pr_Date=pro.Pr_Date,processname=pro.name,Desk=pro.Desk,RelativeDayStr=pro.RelativeDayStr)
                    #Check process conditions (presence of inputs, time constraints, frequency)
                    Cond=pro.Conditions()
                    
                    #If conditions are verified and process not already running (__eq__ defined as True
                    #when process date and name are the same)
                    if Cond is True and Output_ not in procs.values():
                        
                        print(f'Adding process {pro.name}')
                        procs[executor.submit(pro.run)]=Output_
                        
                    elif isinstance(Cond,str):
                        #If conditions are not met, correspondng error message is recorded in the log.
                        print(Cond)
                        #Generate log
                        Output_.GenerateResult(Cond)
                     
                        
                       
                procsList = list(procs.keys())
                
              #Check for completed threads and logs the result
                for proc in procsList:
                    if proc.done():
                        
                        logresult(proc)
                
        except:
            
            pass
        
        time.sleep(30)